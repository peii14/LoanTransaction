function recommend(uint 8 score, address recommenderAddress) {
    if (recomenderAddress != borrower) {
        print "you can not recommend your own project"
        return;
    }
    if( score > minimumRecemmendVallue && score <= 100) continue;
    else return;
    if(!recommenders(recommenderAddress)){
        print "you have already recommended"
        return
    }
    if( msg.value >= collateral){
         extraMoney = msg.value - collateral
         if( collateral == msg.value - extraMoney) continue
         else return

         if(extraMoney <= msg.value) continue
         else return

         if (extraMoney > 0) {
            // return extra money to the sender
            payable(recommenderAddress).transfer(extraMoney);
            ExtraAmountRefunded(recommenderAddress, extraMoney, block.timestamp);
        }
     }else{
        collateral -= (msg.value - extraMoney);
     }

    uint recommendedAmount = msg.value - extraMoney;
    totalRecommendedAmount += recommendedAmount;
    recommenders[recommenderAddress] = true;
    recommendedAmounts[recommenderAddress] = recommendedAmount;
    recommendedScore[recommenderAddress] = score;

    recommenderAddr.push(recommenderAddress);
    recommendersCount++;

    (weights, scores) = TScoreController.getRecommendersWeightsAndValue(recommendersCount, recommenderAddr, recommenders, recommendedAmounts, totalRecommendedAmount, recommendedScore);
    TScoreController.updateSocialRecommendationScore(address(this), borrowerUser, 0, 0,weights, scores);

    isNew = false;

    Recommended(recommenderAddress, recommendedAmount, block.timestamp);
    if (collateral == 0)
        state = State.investment;
}

function Lend(address investorAddress){
    if(investorAddress != borrower){
        print "you can not invest in your own project"
        return
    }
    if(msg.value > requestAmount){
        extraMoney = address(this).balance - requestAmount
        if(requestAmount == addres(this).balance - extraMoney){
            continue
        }else return

        if(extraMoney <= msg.value){
            continue
        }else return

        if (extraMoney > 0) {
            payable(investorAddress).transfer(extraMoney);
            ExtraAmountRefunded(investorAddress, extraMoney, block.timestamp);
        }
    }
    totalInvestedAmoubnt += msg.value = extraMoney
    investorsCount++;
    lenders[investorAddress] = true;
    investedAmounts[investorAddress] =msg.value - extraMoney);

    Invested(investorAddress,msg.value -extraMoney), block.timestamp);

    if (collateral == 0 && totalInvestedAmount == requestedAmount)
        state = State.withdrawable;
}

function repay(){
    if(repaidAmount < returnAmount) continue
    else return

    if(msg.value >= repaymentInstallment.mantissa) continue
    else return

    lastRepaymentDate = block.timestamp;
    repaidAmount += (msg.value - extraMoney);

    LogBorrowerRepaymentInstallment(msg.sender, msg.value - extraMoney, block.timestamp);
    if(repaidAmount >- returnAmount){
        LogBorrowerRepaymentFinished(msg.sender, block.timestamp);

            // once the loan is finished, investors can ask for interest
            state = State.interestReturns;
            LoanStateChanged(state, block.timestamp);

            // increase user's TScore after a successful loan project
            if (User(borrowerUser).getSocialRecommendationScore() - successfulLoanScoreIncrease <= 100)
                User(borrowerUser).setSocialRecommendationScore(User(borrowerUser).getSocialRecommendationScore() + successfulLoanScoreIncrease);
            else
                User(borrowerUser).setSocialRecommendationScore(100);
    }
}

function claimWithInterest() {
    checkFraud();

    if(lenders[msg.sender]){
        // Calculate the interest amount to return to the lender
        returnInterestAmount += ExponentialNoError.mul_ScalarTruncateAddUInt(
            // multiply the amount by the interest rate
            ExponentialNoError.div_(ExponentialNoError.Exp({ mantissa: interest*(100 - recommendersInterestRate)*1e18}), 10000),
            investedAmounts[msg.sender],
            investedAmounts[msg.sender]
        );
        investedAmounts[msg.sender] = 0;
    }
    if (recommenders[msg.sender]) {
         // Calculate the interest amount to return to the recommender
        if(state != State.fraud){
            recommendedAmount = recommendedAmounts[msg.sender]
        }else{
            // Multiply an ExponentialNoError.Exp by a scalar, then truncate to return an unsigned integer.
            recomendedAmount = ExponentialNoError.mul_ScalarTruncate(
                ExponentialNoError**{ mantissa: (totalRecommendedAmount - repaidAmount)}/ totalRecommendedAmount
                , recommendedAmounts[msg.sender])
        }

        // Multiply an ExponentialNoError.Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.
        // multiply the amount by the interest rate
        returnInterestAmount += ExponentialNoError.mul_ScalarTruncateAddUInt(
            10**{ mantissa: interest*recommendersInterestRate*1e18}/ 10000,
            recommendedAmount,
            recommendedAmount
        );
        recommendedAmounts[msg.sender] = 0;

        
    }
    if (returnInterestAmount > address(this).balance)
        returnInterestAmount = address(this).balance;

    if(address(this).balance >= returnInterestAmount) continue
    else return

    // Transfer the return amount with interest to the lender.
    payable(msg.sender).transfer(returnInterestAmount);

    // Log the transfer to lender.
    LogLenderWithdrawal(msg.sender, returnInterestAmount, block.timestamp);


    if(address(this).balance == 0){
        LoanController(loanController).finishLoan(borrower);
        this.destructLoan(payable(address(0)));
    }
}

