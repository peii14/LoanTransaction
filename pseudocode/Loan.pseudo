function recommend(score, recommenderAddress) {
    
    if (recomenderAddress != borrower) {
        print "you can not recommend your own project"
        return
    }
    
    if( score > minimumRecemmendVallue && score <= 100) 
        continue;
    else 
        return;
    if(!recommenders(recommenderAddress)){
        print "you have already recommended"
        return
    }
    if( moneyValue >= collateral){
         extraMoney = moneyValue - collateral
         if( collateral == moneyValue - extraMoney) 
            continue
         else 
            return
         if(extraMoney <= moneyValue) 
            continue
         else 
            return
         if (extraMoney > 0) {
            // return extra money to the sender
            refundExtraMoney()
        }
     }else{
        collateral = collateral - (moneyValue - extraMoney);
     }

    recommendedAmount = moneyValue - extraMoney;
    (weights, scores) = getRecomendationWeightAndScore()
    updateSocialRecomendation()
    isNew = false;
    //  
    Recommended(recommenderAddress, recommendedAmount);
    if (collateral == 0){
        updateInvestmentState()
    }
}

function Lend(address investorAddress){
    if(investorAddress != borrower){
        print "you can not invest in your own project"
        return
    }
    if(moneyValue > requestAmount){
        extraMoney = userBalance - requestAmount
        if(requestAmount == userBalance - extraMoney){
            continue
        }else return

        if(extraMoney <= moneyValue){
            continue
        }else return

        if (extraMoney > 0) {
            refundExtraMoney()
        }
    }
    totalInvestedAmount = totalInvestedAmount + moneyValue - extraMoney
    investedAmounts[investorAddress] = moneyValue - extraMoney);

    Invested(investorAddress,moneyValue - extraMoney);

    if (collateral == 0 && totalInvestedAmount == requestedAmount)
        state = ableToWithdraw();
}

function repay(){
    if(repaidAmount < returnAmount) continue
    else return

    if(msg.value >= repaymentInstallment.mantissa) continue
    else return

    lastRepaymentDate = block.timestamp;
    repaidAmount += (msg.value - extraMoney);

    // LogBorrowerRepaymentInstallment(msg.sender, msg.value - extraMoney, block.timestamp);
    createBorrowerLog()
    if(repaidAmount >= returnAmount){
            // once the loan is finished, investors can ask for interest
            state = State.interestReturns;
            LoanStateChanged(state, block.timestamp);

            // increase user's TScore after a successful loan project
            if (borowerSocialScore- successfulLoanScoreIncrease <= 100)
                updateBorrowerSocialScore()+ successfulLoanScoreIncrease;
            else
                setBorrowerSocialScore(100)
    }
}

function claimWithInterest() {
    checkFraud();

    if(lender == True){
        // Calculate the interest amount to return to the lender
        returnInterestAmount =returnInterestAmount + ExponentialNoError.mul_ScalarTruncateAddUInt(
            // multiply the amount by the interest rate
            // SIMPLIFY
            ExponentialNoError.div_(ExponentialNoError.Exp({ mantissa: interest*(100 - recommendersInterestRate)*1e18}), 10000),
            investedAmounts[msg.sender],
            investedAmounts[msg.sender]
        );
        investedAmounts[msg.sender] = 0;
    }
    if (recomender == True) {
         // Calculate the interest amount to return to the recommender
        if(state != State.fraud){
            recommendedAmount = recommendedAmounts[msg.sender]
        }else{
            // Multiply an ExponentialNoError.Exp by a scalar, then truncate to return an unsigned integer.
            recomendedAmount = ExponentialNoError.mul_ScalarTruncate(
                ExponentialNoError**{ mantissa: (totalRecommendedAmount - repaidAmount)}/ totalRecommendedAmount
                , recommendedAmounts[msg.sender])
        }

        // Multiply an ExponentialNoError.Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.
        // multiply the amount by the interest rate
        returnInterestAmount += ExponentialNoError.mul_ScalarTruncateAddUInt(
            10**{ mantissa: interest*recommendersInterestRate*1e18}/ 10000,
            recommendedAmount,
            recommendedAmount
        );
        recommendedAmounts[msg.sender] = 0;

        
    }
    if (returnInterestAmount > address(this).balance)
        returnInterestAmount = address(this).balance;

    if(address(this).balance >= returnInterestAmount) continue
    else return

    // Transfer the return amount with interest to the lender.
    payable(msg.sender).transfer(returnInterestAmount);

    // Log the transfer to lender.
    LogLenderWithdrawal(msg.sender, returnInterestAmount, block.timestamp);

    if(address(this).balance == 0){
        LoanController(loanController).finishLoan(borrower);
        this.destructLoan(payable(address(0)));
    }
}

